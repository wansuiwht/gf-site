---
slug: '/quick/scaffold-boost'
title: 'Project Initialization'
hide_title: true
sidebar_position: 0
keywords: [GoFrame Framework, Project Initialization, Program Initialization, main.go, Bootstrap Initialization, Route Registration, HTTP Server, Group Routes, Route Objects, Blocking Operation]
description: "When you start your first project, you may feel confused about the engineering directory, but through this chapter, you can understand the project startup process and the directories involved. The main program entry is main.go, which guides the program startup by invoking the internal/cmd package. The default created HTTP Server supports multiple route registrations, making project initiation simple and fast. For specific usage details, please refer to the relevant documentation of the GoFrame framework."
---

When you start your first project, you may feel confused about the many directories under the project. No worries, through this chapter [Project Directory DesignğŸ”¥](../../docs/æ¡†æ¶è®¾è®¡/å·¥ç¨‹å¼€å‘è®¾è®¡/å·¥ç¨‹ç›®å½•è®¾è®¡.md), you can understand the role of each directory. Next, we will introduce how the project is initiated and which directories are linked in the program's startup, providing an understanding of the overall startup process.

## main.go

All program entries start from `main.go`. This file mainly invokes the `internal/cmd` package's corresponding command to guide the program startup. In the project template, the default action is executing the `internal/cmd` package's `Main` object's `Run` command to guide the program startup.

All the core business logic of the project is placed in the `internal` directory, which is a feature of `Golang` designed to hide visibility from the outside. The code content under the `internal` directory cannot be imported externally, enhancing the project's security and simplicity.

:::tip
The core components of the framework need to pass the `context` context parameter. Here, `gctx.GetInitCtx` indicates inheriting the trace information of the parent process. If there is no parent process, a `context` context object with tracing features will be created for downstream linking.
:::

![main.go](QQ_1731652866651.png)

## Bootstrap Initialization

The main purpose of the `Run` command of the `Main` object is to perform bootstrap initialization, placing some dynamic initialization logic in the `Run` method of `Main`. In the project template, an `HTTP Server` is created by default, then routes are registered through grouped routing, and the `HTTP Server` is started. Afterwards, the `HTTP Server` will block and run, while also asynchronously listening for system signals. Upon receiving an exit signal, it will gracefully close connections and then exit the process.

:::tip
The framework's command-line management defaults to a structured object management method. For a detailed introduction, please refer to the chapter: [Command Management](../../docs/æ ¸å¿ƒç»„ä»¶/å‘½ä»¤ç®¡ç†/å‘½ä»¤ç®¡ç†.md)
:::

![main command](QQ_1731653678736.png)

## Route Registration

In the project template, a grouped route is created using the `Group` method. The framework's `HTTP Server` **supports multiple route registration methods**, and grouped routing is also the most common registration method.

```go
s := g.Server()
s.Group("/", func(group *ghttp.RouterGroup) {
    group.Middleware(ghttp.MiddlewareHandlerResponse)
    group.Bind(
        hello.NewV1(),
    )
})
```

- Inside the closure method of the grouped route, a middleware is registered through the `Middleware` method. This middleware is used by the `HTTP Server` component to standardize the data return of routes.
- Afterwards, a route object returned by `hello.NewV1()` is bound through the standardized route method of the `Bind` method. All public methods under this route object will be automatically registered to the route. Our project scaffold supports version management of APIs. By default, our route objects are version `v1`, created through the method `NewV1`.

:::tip
For a detailed introduction of HTTP Server routes, please refer to the chapter: [Route ManagementğŸ”¥](../../docs/WEBæœåŠ¡å¼€å‘/è·¯ç”±ç®¡ç†/è·¯ç”±ç®¡ç†.md)
:::

## Route Objects


### Object Creation
Route objects are returned by the `hello.NewV1()` method, defined as follows:

![alt text](QQ_1731655173428.png)

As you can see, the `NewV1` method actually returns an API rather than a specific object. The API is defined as follows:

![alt text](QQ_1731655571221.png)

Why not return the `ControllerV1` object directly here but return the `hello.IHelloV1` API instead?

Imagine if we defined many `api` APIs, but the concretely implemented `controller` only implemented a portion of them, and we could only find this out at runtime. How could we discover this problem early? Correct, by relying on this API implementation. If the `controller` only implements part of the API, compilation will display errors, and modern editors will also alert warnings ahead of time.

:::tip
Firstly, it is not necessary to do so. The scaffold template offers a more rigorous code writing method.

Secondly, most of the code here is automatically generated by the `cli` tool's `gf gen ctrl` command by analyzing the API definition of the `api` directory.
:::

### Function Definition
The corresponding route function is defined as follows:

![alt text](QQ_1731655216354.png)

The route information corresponding to the `Hello` method is defined in the `HelloReq` input parameter object, whose data structure is defined as follows:

![alt text](QQ_1731655423345.png)

:::tip
This method of managing routes through a unified middleware that returns a uniform data structure and route objects is called **standardized routing**.
For a more detailed introduction, please refer to the chapter: [Route Registration - Standardized Routing](../../docs/WEBæœåŠ¡å¼€å‘/è·¯ç”±ç®¡ç†/è·¯ç”±ç®¡ç†-è·¯ç”±æ³¨å†Œ/è·¯ç”±æ³¨å†Œ-è§„èŒƒè·¯ç”±/è·¯ç”±æ³¨å†Œ-è§„èŒƒè·¯ç”±.md).
:::

## Running the Service

### Blocking Operation

The `HTTP Server` is started through the `Run` method of the `HTTP Server`, and the `HTTP Server` will block and run, receiving client requests, and listening for process signals for `HTTP Server` restart/closure.

After running, the terminal outputs the following:

![alt text](QQ_1731657619286.png)

You can see that we have enabled the API documentation and `Swagger UI`.

### Viewing Results

We visit http://127.0.0.1:8000/hello to see the API results:

![demo hello world](QQ_1731657717720.png)

We visit http://127.0.0.1:8000/swagger to see the `Swagger UI`:

![demo swagger ui](QQ_1731657799765.png)



## Learning Summary

Through the study of this chapter, we have understood the execution process of the scaffold project template program.
There are actually a lot of details here that are not explained in depth. If interested, you can explore the relevant documentation under the corresponding section.

In the next chapter, we will try to write a simple `CRUD` API through the scaffold project template to achieve add, delete, query, and modify operations on database tables.